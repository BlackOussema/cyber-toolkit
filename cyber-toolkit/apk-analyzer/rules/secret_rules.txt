#!/usr/bin/env python3
"""
apk-analyzer/analyze.py
Usage:
python3 analyze.py path/to/app.apk [-o report.json] [--no-mobsf] [--rules rules.txt] [--keep-temp]

Requirements:
- Python 3.8+
- requests (optional, for MobSF)
- apktool (in PATH) -- optional if using MobSF
- jadx (in PATH) -- optional but recommended
- MobSF (optional) running at http://localhost:8000 (or set MOBSF_API env)
"""
import argparse
import os
import sys
import tempfile
import shutil
import subprocess
import json
import re
import requests
from pathlib import Path

# Config
DEFAULT_MOBSF_URL = os.environ.get("MOBSF_URL", "http://localhost:8000")
DEFAULT_MOBSF_KEY = os.environ.get("MOBSF_API_KEY", "") # leave empty if MobSF API key not set

# Default secret regex rules (fallback if no rules file provided)
DEFAULT_RULES = [
r"(?i)api[_-]?key",
r"(?i)secret",
r"(?i)access[_-]?token",
r"(?i)client[_-]?secret",
r"(?i)aws[_-]?secret",
r"(?i)password\s*[:=]",
r"AKIA[0-9A-Z]{16}", # AWS Access Key ID pattern
r"(?i)ssh-rsa\s+[A-Za-z0-9+/]+={0,3}\s", # embedded public key
r"(?i)-----BEGIN PRIVATE KEY-----"
]

def run_cmd(cmd, cwd=None, timeout=300):
proc = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
try:
out, err = proc.communicate(timeout=timeout)
except subprocess.TimeoutExpired:
proc.kill()
out, err = proc.communicate()
return {"returncode": proc.returncode, "stdout": out, "stderr": err, "timeout": True}
return {"returncode": proc.returncode, "stdout": out, "stderr": err, "timeout": False}

def mobsf_upload(apk_path, mobsf_url=DEFAULT_MOBSF_URL, api_key=DEFAULT_MOBSF_KEY):
"""
Upload APK to MobSF and fetch JSON report.
Requires MobSF running and its API endpoint available.
"""
upload_url = mobsf_url.rstrip("/") + "/api/v1/upload"
headers = {"Authorization": api_key} if api_key else {}
files = {"file": open(apk_path, "rb")}
try:
r = requests.post(upload_url, files=files, headers=headers, timeout=60)
r.raise_for_status()
j = r.json()
apk_hash = j.get("hash")
if not apk_hash:
return {"error": "No hash in MobSF upload response", "response": j}
report_url = mobsf_url.rstrip("/") + f"/api/v1/report_json?hash={apk_hash}"
rr = requests.get(report_url, headers=headers, timeout=60)
rr.raise_for_status()
return {"report": rr.json()}
except Exception as e:
return {"error": str(e)}

def run_apktool(apk_path, out_dir):
cmd = ["apktool", "d", "-f", apk_path, "-o", out_dir]
return run_cmd(cmd)

def run_jadx(apk_path, out_dir):
cmd = ["jadx", "-d", out_dir, apk_path]
return run_cmd(cmd, timeout=600)

def parse_manifest(manifest_path):
"""
Very light parsing of AndroidManifest.xml produced by apktool.
Extract uses-permission, package name, and activity names.
"""
try:
text = Path(manifest_path).read_text(encoding="utf-8", errors="ignore")
except Exception as e:
return {"error": f"could not read manifest: {e}"}
res = {"permissions": [], "package": None, "activities": []}
# package name
mpack = re.search(r'package="([^"]+)"', text)
if mpack:
res["package"] = mpack.group(1)
# permissions
perms = re.findall(r'<uses-permission(?:[^>]*?)android:name="([^"]+)"', text)
res["permissions"] = sorted(list(set(perms)))
# activities (approx)
acts = re.findall(r'<activity(?:[^>]*?)android:name="([^"]+)"', text)
res["activities"] = sorted(list(set(acts)))
return res

def load_rules(rules_file=None):
rules = []
if rules_file and os.path.exists(rules_file):
with open(rules_file, "r", encoding="utf-8") as f:
for ln in f:
ln = ln.strip()
if not ln or ln.startswith("#"):
continue
try:
rules.append(ln)
except:
pass
if not rules:
rules = DEFAULT_RULES
# compile
try:
cre = [re.compile(r) for r in rules]
except re.error:
# fallback: literal strings
cre = [re.compile(re.escape(r), re.IGNORECASE) for r in rules]
return cre

def search_secrets(paths, compiled_rules, max_hits_per_rule=50):
findings = []
seen = set()
for p in paths:
if os.path.isfile(p):
files = [p]
else:
files = []
for root, _, filenames in os.walk(p):
for fn in filenames:
# only search in text-like files
if fn.endswith((".smali", ".xml", ".java", ".kt", ".txt", ".properties", ".json", ".yml", ".yaml", ".gradle", ".config")) or "." in fn:
files.append(os.path.join(root, fn))
for f in files:
try:
with open(f, "r", encoding="utf-8", errors="ignore") as fh:
for i, line in enumerate(fh, start=1):
for cre in compiled_rules:
for m in cre.finditer(line):
key = (cre.pattern, f, i, m.group(0))
if key in seen:
continue
seen.add(key)
findings.append({
"rule": cre.pattern,
"file": f,
"line": i,
"match": m.group(0).strip()[:400]
})
if len(findings) >= max_hits_per_rule:
break
except Exception:
continue
return findings

def main():
ap = argparse.ArgumentParser(description="APK Analyzer: MobSF + apktool + jadx + secrets search")
ap.add_argument("apk", help="Path to APK file")
ap.add_argument("--out", "-o", default="-", help="Output JSON file (use - for stdout)")
ap.add_argument("--no-mobsf", action="store_true", help="Do not attempt MobSF upload")
ap.add_argument("--rules", help="Path to rules file (one regex per line)")
ap.add_argument("--keep-temp", action="store_true", help="Keep temporary folders for inspection")
args = ap.parse_args()

apk_path = os.path.abspath(args.apk)
if not os.path.exists(apk_path):
print(json.dumps({"error": f"APK not found: {apk_path}"}))
sys.exit(2)

report = {"apk": apk_path, "errors": [], "mobsf": None, "apktool": None, "jadx": None, "manifest": None, "secrets": []}
temp_root = tempfile.mkdtemp(prefix="apk_analyzer_")
apktool_out = os.path.join(temp_root, "apktool_out")
jadx_out = os.path.join(temp_root, "jadx_out")

# 1) MobSF (optional)
if not args.no_mobsf:
try:
mobsf_res = mobsf_upload(apk_path)
if mobsf_res.get("error"):
report["mobsf"] = {"error": mobsf_res["error"]}
else:
report["mobsf"] = mobsf_res["report"]
except Exception as e:
report["mobsf"] = {"error": str(e)}

# 2) apktool
apktool_res = run_apktool(apk_path, apktool_out)
report["apktool"] = {"returncode": apktool_res["returncode"], "stdout_tail": apktool_res["stdout"][-2000:], "stderr_tail": apktool_res["stderr"][-2000:]}
if apktool_res["returncode"] != 0:
report["errors"].append("apktool failed (see apktool stderr)")

# parse manifest if exists
manifest_path = os.path.join(apktool_out, "AndroidManifest.xml")
if os.path.exists(manifest_path):
report["manifest"] = parse_manifest(manifest_path)
else:
report["manifest"] = {"error": "manifest not found in apktool output"}

# 3) jadx
jadx_res = run_jadx(apk_path, jadx_out)
report["jadx"] = {"returncode": jadx_res["returncode"], "stdout_tail": jadx_res["stdout"][-2000:], "stderr_tail": jadx_res["stderr"][-2000:]}
if jadx_res["returncode"] != 0:
report["errors"].append("jadx failed (see jadx stderr)")

# 4) secrets scan
compiled = load_rules(args.rules)
# search in apktool output and jadx output (both)
search_paths = [apktool_out, jadx_out]
findings = search_secrets(search_paths, compiled)
report["secrets"] = findings

# 5) cleanup unless keep-temp
if args.keep_temp:
report["_temp_dirs"] = {"apktool": apktool_out, "jadx": jadx_out}
else:
try:
shutil.rmtree(temp_root)
except Exception:
pass

# 6) output
if args.out == "-" or args.out == "-":
print(json.dumps(report, indent=2))
else:
with open(args.out, "w", encoding="utf-8") as fo:
json.dump(report, fo, indent=2)
print(f"Wrote report to {args.out}", file=sys.stderr)

if __name__ == "__main__":
main()
